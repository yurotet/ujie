{
  "name": "oo-class",
  "version": "1.4.4",
  "author": {
    "name": "tangoboy",
    "email": "137757831@qq.com"
  },
  "description": "A simple OO Class factory",
  "main": "class.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/fengdi/Class.js.git"
  },
  "keywords": [
    "class",
    "Class",
    "Constructor",
    "prototype",
    "inheritance",
    "class inheritance"
  ],
  "license": "MIT",
  "analyze": false,
  "devDependencies": {
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha ./test"
  },
  "engines": {
    "node": ">=0.6"
  },
  "readme": "Class.js v1.4.4[![Build Status](https://travis-ci.org/fengdi/Class.js.svg?branch=master)](https://travis-ci.org/fengdi/Class.js)\r\n========\r\noop javascript\r\n\r\n## 特性 ##\r\n\r\n- 和原生创建的类是一致的，实例化的对象不包含额外任何成员和添加剂\r\n\r\n\t\tvar a = new A();\r\n\t\tfor(var k in a){\r\n\t\t\tconsole.log(k);  //没有多余的成员\r\n\t\t}\r\n\r\n- 创建的类实例化时支持可以不使用new关键字实例化 \r\n\r\n\t\tvar a = new A();\r\n\t\tvar a = A();         //可以省略new\r\n\r\n- 使用的继承方式保证原型链和对象检测，尽量靠近原生继承和实例化机制\r\n\t\t\r\n\t\tsub instanceof SuperClass //true 可以用instanceof检测\r\n\r\n\t\tvar A = $Class.create({\r\n\t\t\t__:function(){\r\n\t\t\t\treturn {};        //实例化A时返回{}而不是实例,和原生一致\r\n\t\t\t}\r\n\t\t});\r\n\r\n- 提供创建单例类的接口，单例类区别于单例对象{}, 需要实例化且可以继承\r\n\t\r\n\t\tvar S = $Class.singleton({\r\n\t\t\tfoo:function(){\r\n\t\t\t\tconsole.log('foo');\r\n\t\t\t}\r\n\t\t});\r\n\t\tvar s1 = new S();\r\n\t\tvar s2 = new S();  // s1 === s2\r\n \r\n\r\n\r\n## API ##\r\n\r\nClass.js统一的访问命名是$Class, 当你使用此库时，应该$Class.xxx(...)来调用API\r\n\r\n#### 1.创建一个类 ####\r\n\r\n\t\t$Class.create( classMemberObject );\r\n\r\nclassMemberObject定义类的成员，其中属性__（双下划线）约定为构造方法。\r\n\r\n如：\r\n\t\t\r\n\t\tvar A = $Class.create({\r\n\t\t\t__:function(){\r\n\t\t\t\tconsole.log('A构造方法');\r\n\t\t\t}\r\n\t\t});\r\n\r\n\r\n这里实例化的A类的成员是不包含任何污染的，`var a = new A();`可以用for in遍历检测一下a的所有成员。\r\n\r\n\r\n#### 2.创建一个子类 ####\r\n\r\n\t\t$Class.inherit( SuperClass, subClassMemberObject);\r\nSuperClass为父类，subClassMemberObject是定义子类的成员，其中属性__（双下划线）约定为构造方法。\r\n\r\n如：\r\n\t\t\r\n\t\tvar B = $Class.inherit(A, {\r\n\t\t\t__:function(){\r\n\t\t\t\tconsole.log('B构造方法');\r\n\t\t\t}\r\n\t\t});\r\n\r\n或者使用父类提供的$extend方法：\r\n\r\n\t\tSuperClass.$extend( subClassMemberObject )\r\n\r\nsubClassMemberObject是定义子类的成员，其中属性__（双下划线）约定为构造方法。\r\n\r\n如：\r\n\r\n\t\tvar B = A.$extend({\r\n\t\t\t__:function(name){\r\n\t\t\t\tthis.name = name;\r\n\t\t\t\tconsole.log('B构造方法');\r\n\t\t\t}\r\n\t\t});\r\n\r\n\r\n这里创建好的B类，是可以用 instanceof 去检测的 `(new B()) instanceof A  //true`\r\n\r\n\r\n#### 3.拓展原型成员 ####\r\n通常使用 `A.prototype.xxx = foo;`方式拓展。\r\n这里提供了混入的方式：\r\n\r\n\t\t$Class.include(Class, prototype)\r\n如：\r\n\r\n\t\t$Class.include(A, {\r\n\t\t\txxx:foo\t\t\r\n\t\t});\r\n\r\n\r\n#### 4.实例化某个类 ####\r\n实例化类通常可以用new关键字， 这里提供了new方法，效果和new是一样的。\r\n\r\n\t\t$Class['new']( Class, [argsArray] );\r\n\r\nClass为类，argsArray为参数（数组）\r\n\r\n如：\r\n\r\n\t\t$Class['new'](B, ['tangobot']);  //等同于 new B('tangobot');\r\n\r\n#### 5.单例类 ####\r\n创建一个单例类\r\n\r\n\t\t$Class.singleton( [classMemberObject] )\r\n\r\nclassMemberObject是定义子类的成员，其中属性__（双下划线）约定为构造方法。\r\n\r\n如：\r\n\r\n\t\tvar S = $Class.singleton({foo:\"foo\"});\r\n\t\tvar s1 = new S();\r\n\t\tvar s2 = new S();\r\n\t\ts1 === s2;  // true\r\n\t\tconsole.log(s1.foo) //\"foo\"\r\n\r\n#### 6.成员检测 ####\r\n\r\n\t\t$Class.member( Class );\r\n\r\n返回某个类的原型链上所有定义的成员名称（数组）\r\n如：\r\n\r\n\t\tvar C = $Class.create({\r\n\t\t\tfoo:'ccc',\r\n\t\t});\r\n\t\tvar D = C.$extend({\r\n\t\t\tbar:'ddd'\r\n\t\t});\r\n\t\t$Class.member(D);   //['bar', 'foo']\r\n\r\n\t\t\r\n\t\t\r\n#### 7.Base基类 ####\r\n\r\n\t\t$Class.Base;\r\n\r\n所有create出来的类都是继承自内置的基类`$Class.Base`， $Class.Base继承于系统环境中的Object。\r\n\r\n如:\r\n\r\n\t\tvar Foo = $Class.create();  \r\n\t\t//继承关系为\t Foo <= $Class.Base <= Object\r\n\r\n这里可以重写或者拓展 $Class.Base 来达到拓展Foo类的目的， \r\n你也可以删除$Class.Base 或者 $Class.Base = null 这样就可以改变继承为 Foo <= Object\r\n\r\n\r\n\r\n#### 8.全局配置 ####\r\n\r\n\t\t$Class.config( [configObject|configName] )\r\n\r\n配置项及默认值：\r\n\r\n        constructorName:'__',       //构造方法约定名称，默认约定为双下划线__\r\n\t\tautoSuperConstructor:false, //当子类被实例化时是否先执行父类构造函数 设置后仅对后面声明的类有效\r\n\t\tnotUseNew:true,             //是否可以不使用关键字new 直接调用方法实例化对象 如：A()\r\n\t\tuseExtend:true,             //是否使用让类拥有拓展继承的方法 如：B = A.$extend({})\r\n\t\tuseSuper:true,              //是否让类有$super属性访问父类成员 如：B.$super.foo()\r\n\t\tdisguise:false,             //是否让代码生成的构造函数伪装成定义的__:function(){}\r\n\t\tuseConstructor:true  \t\t//是否使用B.$constructor来保存定义的__构造函数，这里create inherit生成的构造函数是不等于__的\r\n\r\n配置后，仅对后面的生成的类才会产生效果。\r\n\r\n如：\r\n\t\r\n\t$Class.config({notUseNew:false}); //设置后，必须用new实例化对象\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fengdi/Class.js/issues"
  },
  "_id": "oo-class@1.4.4",
  "dist": {
    "shasum": "a862ca645778fb5034e2b0112077b32e55ec2674"
  },
  "_from": "oo-class@^1.4.4",
  "_resolved": "https://registry.npmjs.org/oo-class/-/oo-class-1.4.4.tgz"
}
